#!/usr/bin/perl

use strict;
use utf8;
use warnings;

our $SRC = "data/IdnaTest.txt";
open IdnaTest, '<', $SRC || die "cannot open $SRC: $!";
binmode IdnaTest, ':utf8';

my @tests;

my $line = 0;
while(<IdnaTest>) {
  chomp; ++$line;
  s/\s*#.*//; next if !m/\S/;

  my @c = ($line, split /;/);
  foreach(@c) { s/^\s+//; s/\s+$//; };

  die "format error: '$_' $#c <@c>" if $#c < 4;
  die "unknown test type: $c[1]" if $c[1] !~ m/^(B|N|T)$/;
  
  push @tests, \@c;
}

die "no tests" unless @tests;

write_test('', 		'unicode', 3, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'unicode', 3, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
write_test('', 		'ascii', , 4, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'ascii', , 4, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
exit(0);

sub write_test {
  my($type, $to, $column, $para) = splice @_,0,4;

  my $fn = "t/uts46_to_$to$type.t";

  print STDERR "generating $fn\n" if -t STDERR;

  open STDOUT, ">", $fn || die "cannot open $fn: $!";
  binmode STDOUT, ":utf8";
  
  my $c = $#_ + 1;

  print <<__EOF;
# *** DO NOT EDIT *** generated file *** DO NOT EDIT ***
#
# generated by $0 from $SRC
# see repository at http://github.com/cfaerber/Net-IDN-Encode for source files
#
use strict;
use utf8;
use warnings;

use Test::More tests => $c + 1;
use Test::NoWarnings;

use Net::IDN::Encode qw(:all);

my \$builder = Test::More->builder;
binmode \$builder->output,         ":utf8";
binmode \$builder->failure_output, ":utf8";
binmode \$builder->todo_output,    ":utf8";

no warnings 'utf8';

__EOF
  print "my %p = (".qhash(%{$para}).");\n\n";

  foreach (@_) {
    my $line = $_->[0];
    my $src  = $_->[2];
    my $dest = $_->[$column];
    
    $dest = $src if $dest eq '' && ($src !~ m/^\\u200[CD]$/); # ouch
    my $err = '';

    my $com = "to_$to('".$src."')";

    if($dest =~ m/^\[(.*)\]$/) {
      $dest = undef;
      $com .= " is error $1";
    }

    $com .= " [$SRC:$line]";

    print "is(eval{to_$to(", qstr($src), ",\t%p)}, ", qstr($dest), ',', "\t", '"', quotemeta($com), '"', ");\n";

  }
  print "\n\nexit(0);\n";

  close STDOUT;
}

sub qhash {
  my %h = @_; my $s = '';
  foreach(sort keys %h) {
    $s .= ', ' if $s;
    $s .= qstr($_);
    $s .= ' => '.qstr($h{$_});
  }
  return $s;
}

sub qstr {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/([\\\$\@\"])/\\$1/g;
  $s =~ s/\\\\u(D[89AB][[:xdigit:]]{2})\\\\u(D[CDEF][[:xdigit:]]{2})/
	sprintf('\x{%04X}', 0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\\\u([[:xdigit:]]{4})/\\x{$1}/gi;
  return '"'. $s. '"';
}
