#!/usr/bin/perl

use strict;
use utf8;
use warnings;

no warnings 'utf8';

our $SRC = "data/IdnaTest.txt";
open IdnaTest, '<', $SRC || die "cannot open $SRC: $!";
binmode IdnaTest, ':utf8';

my @tests;

while(<IdnaTest>) {
  chomp; 
  s/\s*#.*//; next if !m/\S/;

  my @c = ($., split /;/);
  foreach(@c) { s/^\s+//; s/\s+$//; };

  die "format error: '$_' $#c <@c>" if $#c < 4;
  die "unknown test type: $c[1]" if $c[1] !~ m/^(B|N|T)$/;
  
  push @tests, \@c;
}

die "no tests" unless @tests;

write_test('', 		'unicode', 3, { 'TransitionalProcessing' => 0, }, @tests);
write_test('', 		'ascii', , 4, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'ascii', , 4, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
exit(0);

sub write_test {
  my($type, $to, $column, $para, $min_perl) = splice @_,0,4;

  my $fn = "t/uts46_to_$to$type.t";

  print STDERR "generating $fn\n" if -t STDERR;

  open STDOUT, ">", $fn || die "cannot open $fn: $!";
  binmode STDOUT, ":utf8";
  
  my $c = $#_ + 1;

  print <<__EOF;
# *** DO NOT EDIT *** generated file *** DO NOT EDIT ***
#
# generated by $0 from $SRC
# see repository at http://github.com/cfaerber/Net-IDN-Encode for source files
#
use strict;
use utf8;
use warnings;

BEGIN {
  binmode STDOUT, ':utf8';
  binmode STDERR, ':utf8';
}

use Test::More tests => $c + 1;
use Test::NoWarnings;

use Unicode::UCD;
use Net::IDN::UTS46 (':all');

no warnings 'utf8';

our \$UCD_VERSION = eval('v'.(Unicode::UCD::UnicodeVersion()));

__EOF
  print "my %p = (".qhash(%{$para}).");\n\n";

  foreach (@_) {
    $.       = $_->[0];
    my $src  = $_->[2];
    my $dest = $_->[$column];

    my $src_u8  = parse_str($src);
    my $dest_u8 = parse_str($dest);

    $dest = $_->[3] if $dest eq '' && $column != 3;
    $dest = $src if $dest eq '';
    my $err = undef;

    my $com = "to_$to('".$src."')";

    if($dest =~ m/^\[(.*)\]$/) {
      $dest = undef;
      $err = $1;
      $com .= " throws error $err";
    }

    my $l_u8 = join '-', map { parse_str($_) } @{$_};
    my ($min_ucd,$min_perl, $need_closing_bracket);
    unless(defined($err) and ($err =~ m/P1/) and ($err =~ m/V6/)) { ## should be invalid anyway

      my %unicode_to_perl_version = (
        v3.2	=> v5.8.0,
        v4.0	=> v5.8.1,
        v4.0.1	=> v5.8.4,
        v4.1	=> v5.8.7,
        v5.0	=> v5.9.5,
        v5.1	=> v5.10.1,
        v5.2	=> v5.11.5,
        v6.0	=> v5.13.7,
        v6.1	=> v5.15.8,
        v6.2	=> v5.17.1,
        v6.3	=> v5.19.5,
	v7.0	=> v5.21.1,
      );
  
      foreach my $ucd_ver (sort keys %unicode_to_perl_version) {
        my $ucd_ver_str = sprintf '%vd', $ucd_ver;
        if(eval{$l_u8 !~ m/\P{Present_In: $ucd_ver_str}/}) { 
   	  $min_ucd = $ucd_ver;
  	  $min_perl = $unicode_to_perl_version{$ucd_ver};
	  last;
        }
      }

      if(!defined $min_ucd) {
        print 'TODO: { local $TODO = "test file was generated on perl '.$].', which is too old"; ';
	$need_closing_bracket++;
      } elsif ($min_perl gt v5.8.5) {	# 5.8.5 required by Net::IDN::UTS46
        print 'SKIP: { skip sprintf("requires UnicodeÂ® ',sprintf('v%vd', $min_ucd),
	  ' (perl ',sprintf('v%vd', $min_perl),') or higher,',
  	  ' only v%vd is supported (perl v%vd)", $UCD_VERSION, $^V)',
  	  ', 1 if $UCD_VERSION lt ',sprintf('v%vd', $min_ucd),'; ';
	$need_closing_bracket++;
      }
    } # unless 

    $com .= " [$SRC:$.]";
    print "is(eval{uts46_to_$to(", qstr($src), ", %p)},\t", qstr($dest), ',', "\t", '"', quotemeta($com), '"', ")",' or ($@ and diag($@))',";";

    if(defined $need_closing_bracket) {
      print ' }';
    }

    print "\n";
  }
  print "\n\nexit(0);\n";

  close STDOUT;
}

sub qhash {
  my %h = @_; my $s = '';
  foreach(sort keys %h) {
    $s .= ', ' if $s;
    $s .= qstr($_);
    $s .= ' => '.qstr($h{$_});
  }
  return $s;
}

sub parse_str {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/\\u(D[89AB][[:xdigit:]]{2})\\u(D[CDEF][[:xdigit:]]{2})/ chr(0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\u([[:xdigit:]]{4})/ chr(hex $1) /gei;
  return $s;
}

sub qstr {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/([\\\$\@\"])/\\$1/g;
  $s =~ s/\\\\u(D[89AB][[:xdigit:]]{2})\\\\u(D[CDEF][[:xdigit:]]{2})/
	sprintf('\x{%04X}', 0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\\\u([[:xdigit:]]{4})/\\x{$1}/gi;
  return '"'. $s. '"';
}
