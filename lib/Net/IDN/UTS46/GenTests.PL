#!/usr/bin/perl

use strict;
use utf8;
use warnings;

our $SRC = "data/IdnaTest.txt";
open IdnaTest, '<', $SRC || die "cannot open $SRC: $!";
binmode IdnaTest, ':utf8';

my @tests;

my $line = 0;
while(<IdnaTest>) {
  chomp; ++$line;
  s/\s*#.*//; next if !m/\S/;

  my @c = ($line, split /;/);
  foreach(@c) { s/^\s+//; s/\s+$//; };

  die "format error: '$_' $#c <@c>" if $#c < 4;
  die "unknown test type: $c[1]" if $c[1] !~ m/^(B|N|T)$/;
  
  push @tests, \@c;
}

die "no tests" unless @tests;

write_test('', 		'unicode', 3, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'unicode', 3, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
write_test('', 		'ascii', , 4, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'ascii', , 4, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
exit(0);

sub write_test {
  my($type, $to, $column, $para) = splice @_,0,4;

  my $fn = "t/uts46_to_$to$type.t";

  print STDERR "generating $fn\n" if -t STDERR;

  open STDOUT, ">", $fn || die "cannot open $fn: $!";
  binmode STDOUT, ":utf8";
  
  my $c = $#_ + 1;

  print <<__EOF;
# *** DO NOT EDIT *** generated file *** DO NOT EDIT ***
#
# generated by $0 from $SRC
# see repository at http://github.com/cfaerber/Net-IDN-Encode for source files
#
use strict;
use utf8;
use warnings;

BEGIN {
  binmode STDOUT, ':utf8';
  binmode STDERR, ':utf8';
}

use Test::More tests => $c; # + 1;
# use Test::NoWarnings;

use Net::IDN::Encode qw(:all);

no warnings 'utf8';

__EOF
  print "my %p = (".qhash(%{$para}).");\n\n";

  foreach (@_) {
    my $line = $_->[0];
    my $src  = $_->[2];
    my $dest = $_->[$column];

    my $src_u8  = parse_str($src);
    my $dest_u8 = parse_str($dest);

    my $skip = undef; my @st = map { parse_str($_) } @_[2..4];

    if(defined $dest) {
      $skip = 1	if grep { m/\P{Assigned}/ } @st;
      $skip = 1	if grep { m/\P{Present_In: 3.2}/ } @st;
    };

    $dest = $src if $dest eq '' && ($src_u8 !~ m/^\p{Join_Control}$/); # ouch
    my $err = '';

    my $com = "to_$to('".$src."')";

    if($dest =~ m/^\[(.*)\]$/) {
      $dest = undef;
      $com .= " is error $1";
    }

    $com .= " [$SRC:$line]";

    print "SKIP: { skip 'perl too old', 1; " if $skip;
    print "is(eval{to_$to(", qstr($src), ",\t%p)}, ", qstr($dest), ',', "\t", '"', quotemeta($com), '"', ")",' or ($@ and diag($@))',";";
    print "}" if $skip;
    print "\n";
  }
  print "\n\nexit(0);\n";

  close STDOUT;
}

sub qhash {
  my %h = @_; my $s = '';
  foreach(sort keys %h) {
    $s .= ', ' if $s;
    $s .= qstr($_);
    $s .= ' => '.qstr($h{$_});
  }
  return $s;
}

sub parse_str {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/\\u(D[89AB][[:xdigit:]]{2})\\u(D[CDEF][[:xdigit:]]{2})/ chr(0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\u([[:xdigit:]]{4})/ chr(hex $1) /gei;
  return $s;
}

sub qstr {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/([\\\$\@\"])/\\$1/g;
  $s =~ s/\\\\u(D[89AB][[:xdigit:]]{2})\\\\u(D[CDEF][[:xdigit:]]{2})/
	sprintf('\x{%04X}', 0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\\\u([[:xdigit:]]{4})/\\x{$1}/gi;
  return '"'. $s. '"';
}
